library(shiny)
library(foreign)
library(purrr)
library(dplyr)
library(yaml)
#library(DT)
library("devtools")



# create the ui
ui <- fluidPage(
  
  # Application title
  titlePanel("Free the Data (or SPRING or NECTAR)"),
  mainPanel( 
    h4("ID"),
    # each of the sections of code below create a text input box with a title
    #textInput("id", "ID", "### Generated by R package, not sure how to implement"), #   HTML("#Generated by R package, not sure how to implement"),
    verbatimTextOutput("id2"),
    #tableOutput("display_id"),
    
    
    
    textInput("version", "Version", "version"),
    #verbatimTextOutput("postDate"),
    
    textInput("postDate", "Date uploaded", "Date in ISO format (2019-07-31)"),
    #verbatimTextOutput("postDate"), # this line simply displays what has been inputted into the text field
    
    textInput("sharerName", "Name", "Please type your name here"),
    #verbatimTextOutput("sharerName"),
    
    textInput("sharerEmail", "E-mail address", "type your email address here"),
    #verbatimTextOutput("sharerEmail"),
    
    textInput("label", "Data set label", "a short label for your data"),
    #verbatimTextOutput("label"),
    
    textInput("description", "Description", "a description of the data"),
    #verbatimTextOutput("description")
    
    h3("Basic Table to Updtate as fields are completed"),
     tableOutput("table2")
    ,
    h3("Table Displaying Object that (hopefully) will be saved to YAML"),
     DT::dataTableOutput("table1")
    ,
    actionButton("submit", "Submit", class = "btn-primary")
    
  )
)

# Define server logic required to draw a histogram
server <- function(input, output, session) {
  
  # The lines below create objects from the input
  output$sharerEmail <-  renderText({ input$sharerEmail })
  output$postDate  <- renderText({ input$postDate })
  output$sharerName  <- renderText({ input$sharerName })
  output$label  <- renderText({ input$label })
  output$description  <- renderText({ input$description })
  #output$full_id <-    renderText({rock::numericToBase30(as.numeric(Sys.time())*10000)})

  
  #output$table <- cbind(input$sharerEmail, input$postDate)
  
  # get data object
  get_list<-reactive({

   # if(!exists(input$sharerEmail)) return() # if no upload

  #  check<-function(x){is.null(x) || x==""}
    #if(check(input$sharerEmail)) return()

    obj<-list(#data=get(input$dataset),
      #id=input$id,
      id=rock::numericToBase30(as.numeric(Sys.time())*10000),
      version=input$version,
      postDate=input$postDate,
      sharerName=input$sharerName,
      sharerEmail=input$sharerEmail,
      label=input$label,
      description=input$description
    )

    #require all to be set to proceed
    #if(any(sapply(obj,check))) return()
    
    #make sure choices had a chance to update
    # check<-function(obj){
    #   !all(c(obj$dv,obj$iv,obj$mediator) %in% colnames(obj$data))
    # }
    # 
    # if(check(obj)) return()


    obj

  })
  
  output$id2 <- reactive({big_list <- get_list()
  big_list$id})
  
  fieldsAll <- c("id", "version", "postDate", "sharerName", "sharerEmail","label","description")
  responsesDir <- file.path("responses")
  epochTime <- function() {
    as.integer(Sys.time())
  }
  
  
  get_list_as_df<-reactive({
    
    # if(!exists(input$sharerEmail)) return() # if no upload
    
    #  check<-function(x){is.null(x) || x==""}
    #if(check(input$sharerEmail)) return()
    
    # obj<-list(#data=get(input$dataset),
    #   id=input$id,
    #   version=input$version,
    #   postDate=input$postDate,
    #   sharerName=input$sharerName,
    #   sharerEmail=input$sharerEmail,
    #   label=input$label,
    #   description=input$description
    # )
    
    #require all to be set to proceed
    #if(any(sapply(obj,check))) return()
    
    #make sure choices had a chance to update
    # check<-function(obj){
    #   !all(c(obj$dv,obj$iv,obj$mediator) %in% colnames(obj$data))
    # }
    # 
    # if(check(obj)) return()
    
    
    data <- sapply(fieldsAll, function(x) input[[x]])
    data <- c(data, timestamp = epochTime())
    data <- t(data)
    data
    
    #obj
    
  })
  
  
  observeEvent(input$file1,{
    inFile<<-upload_data()
  })
  
  output$table1 <- DT::renderDataTable({ big_list <- get_list()
                              a <- rbind(
                                #c("id","version","date","sharerName", "sharerEmail","label", "description"),
                                c(big_list$id,
                                  #output$full_id,
                                  big_list$version,
                                  big_list$postDate,
                                  big_list$sharerName,
                                  big_list$sharerEmail,
                                  big_list$label,
                                  big_list$description))
                              colnames(a)<- c("ID","Version","Date","Name", "Email","Label", "Description")
                              a
                              },options = list(lengthChange = FALSE,paging = FALSE))
  
  #output$table3 <- output$table1$sharerEmail
  
  output$table2 <- renderTable({ big_list <- get_list()
  a <- rbind(
    #c("id","version","date","sharerName", "sharerEmail","label", "description"),
    c(big_list$id,
      big_list$version,
      big_list$postDate,
      big_list$sharerName,
      big_list$sharerEmail,
      big_list$label,
      big_list$description))
  colnames(a)<- c("ID","Version","Date","Name", "Email","Label", "Description")
  a
  })
  
  
  output$display_id <- renderTable({ big_list <- get_list()
  a <- rbind(
    c(big_list$id ))
  colnames(a)<- c("ID")
  a
  })
  

  
  id_for_file_name <- reactive({big_list <- get_list()
  big_list$id})
  
    
  
  
  saveData <- function(data){
    fileName <- sprintf("%s.yml",
                        id_for_file_name()
                        #,
                        #digest::digest(data)
                        )
  # write_yaml(stats::setNames(list(list(id = "testId", version=1, postDate="now")), "data_declaration"), stdout())
    write_yaml(stats::setNames(list(data), "data_declaration"), file = file.path(responsesDir, fileName))
  }
  
  
  # action to take when submit button is pressed
  observeEvent(input$submit, {
    saveData(get_list())
  })
  
  
}

# Run the application 
shinyApp(ui = ui, server = server)

