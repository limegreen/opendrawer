library(shiny)
library(foreign)
library(purrr)
library(dplyr)
#library(DT)
library("devtools")



# create the ui
ui <- fluidPage(
  
  # Application title
  titlePanel("Free the Data (or SPRING or NECTAR)"),
  mainPanel( 
    h4("ID"),
    # each of the sections of code below create a text input box with a title
    #textInput("id", "ID", "### Generated by R package, not sure how to implement"), #   HTML("#Generated by R package, not sure how to implement"),
    verbatimTextOutput("id2"),
    #tableOutput("display_id"),
    
    
    
    textInput("version", "Version", "version"),
    #verbatimTextOutput("postdate"),
    
    textInput("postdate", "Date uploaded", "Date in ISO format (2019-07-31)"),
    #verbatimTextOutput("postdate"), # this line simply displays what has been inputted into the text field
    
    textInput("name", "Name", "Please type your name here"),
    #verbatimTextOutput("name"),
    
    textInput("email", "E-mail address", "type your email address here"),
    #verbatimTextOutput("email"),
    
    textInput("label", "Data set label", "a short label for your data"),
    #verbatimTextOutput("label"),
    
    textInput("description", "Description", "a description of the data"),
    #verbatimTextOutput("description")
    
    h3("Basic Table to Updtate as fields are completed"),
     tableOutput("table2")
    ,
    h3("Table Displaying Object that (hopefully) will be saved to YAML"),
     DT::dataTableOutput("table1")
    ,
    actionButton("submit", "Submit", class = "btn-primary")
    
  )
)

# Define server logic required to draw a histogram
server <- function(input, output, session) {
  
  # The lines below create objects from the input
  output$email <-  renderText({ input$email })
  output$postdate  <- renderText({ input$postdate })
  output$name  <- renderText({ input$name })
  output$label  <- renderText({ input$label })
  output$description  <- renderText({ input$description })
  #output$full_id <-    renderText({rock::numericToBase30(as.numeric(Sys.time())*10000)})

  
  #output$table <- cbind(input$email, input$postdate)
  
  # get data object
  get_list<-reactive({

   # if(!exists(input$email)) return() # if no upload

  #  check<-function(x){is.null(x) || x==""}
    #if(check(input$email)) return()

    obj<-list(#data=get(input$dataset),
      #id=input$id,
      id=rock::numericToBase30(as.numeric(Sys.time())*10000),
      version=input$version,
      postdate=input$postdate,
      name=input$name,
      email=input$email,
      label=input$label,
      description=input$description
    )

    #require all to be set to proceed
    #if(any(sapply(obj,check))) return()
    
    #make sure choices had a chance to update
    # check<-function(obj){
    #   !all(c(obj$dv,obj$iv,obj$mediator) %in% colnames(obj$data))
    # }
    # 
    # if(check(obj)) return()


    obj

  })
  
  output$id2 <- reactive({big_list <- get_list()
  big_list$id})
  
  fieldsAll <- c("id", "version", "postdate", "name", "email","label","description")
  responsesDir <- file.path("responses")
  epochTime <- function() {
    as.integer(Sys.time())
  }
  
  
  get_list_as_df<-reactive({
    
    # if(!exists(input$email)) return() # if no upload
    
    #  check<-function(x){is.null(x) || x==""}
    #if(check(input$email)) return()
    
    # obj<-list(#data=get(input$dataset),
    #   id=input$id,
    #   version=input$version,
    #   postdate=input$postdate,
    #   name=input$name,
    #   email=input$email,
    #   label=input$label,
    #   description=input$description
    # )
    
    #require all to be set to proceed
    #if(any(sapply(obj,check))) return()
    
    #make sure choices had a chance to update
    # check<-function(obj){
    #   !all(c(obj$dv,obj$iv,obj$mediator) %in% colnames(obj$data))
    # }
    # 
    # if(check(obj)) return()
    
    
    data <- sapply(fieldsAll, function(x) input[[x]])
    data <- c(data, timestamp = epochTime())
    data <- t(data)
    data
    
    #obj
    
  })
  
  
  observeEvent(input$file1,{
    inFile<<-upload_data()
  })
  
  output$table1 <- DT::renderDataTable({ big_list <- get_list()
                              a <- rbind(
                                #c("id","version","date","name", "email","label", "description"),
                                c(big_list$id,
                                  #output$full_id,
                                  big_list$version,
                                  big_list$postdate,
                                  big_list$name,
                                  big_list$email,
                                  big_list$label,
                                  big_list$description))
                              colnames(a)<- c("ID","Version","Date","Name", "Email","Label", "Description")
                              a
                              },options = list(lengthChange = FALSE,paging = FALSE))
  
  #output$table3 <- output$table1$email
  
  output$table2 <- renderTable({ big_list <- get_list()
  a <- rbind(
    #c("id","version","date","name", "email","label", "description"),
    c(big_list$id,
      big_list$version,
      big_list$postdate,
      big_list$name,
      big_list$email,
      big_list$label,
      big_list$description))
  colnames(a)<- c("ID","Version","Date","Name", "Email","Label", "Description")
  a
  })
  
  
  output$display_id <- renderTable({ big_list <- get_list()
  a <- rbind(
    #c("id","version","date","name", "email","label", "description"),
    c(big_list$id
      # ,
      # big_list$version,
      # big_list$postdate,
      # big_list$name,
      # big_list$email,
      # big_list$label,
      # big_list$description
      ))
  colnames(a)<- c("ID"
                  #,"Version","Date","Name", "Email","Label", "Description"
                  )
  #b <- a[[1]]
  #b
  a
  })
  
 # write(output$table1, "../../table1.yml")
  #responsesDir <- file.path("responses")
  
  humanTime <- function() format(Sys.time(), "%Y%m%d-%H%M%OS")

  
  # humanTime <- function() renderText({big_list <- get_list()
  # print(big_list$id)
  # })
  
    
  saveData <- function(data) {
    fileName <- sprintf("%s_%s.csv",
                        humanTime(),
                        digest::digest(data))

    #fileName <- sprintf("%s_%s.csv",
    #                    output$display_id)

    # fileName <- sprintf("%s_%s.csv",
    #                  humanTime(),
    #                  digest::digest(data))
    # 
    write.csv(x = data, file = file.path(responsesDir, fileName),
              row.names = FALSE, quote = TRUE)
  }
  
  
  saveData2 <- function(data){
    fileName <- sprintf("%s_%s.yml",
                        humanTime(),
                        digest::digest(data))
    
    write_yaml(as.yaml(data), file = file.path(responsesDir, fileName))
  }
  #write_yaml(as.yaml(df), "test2.yml")
  
  # action to take when submit button is pressed
  observeEvent(input$submit, {
    saveData2(get_list())
  })
  
  
}

# Run the application 
shinyApp(ui = ui, server = server)

