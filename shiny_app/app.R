library(shiny)
library(foreign)
library(purrr)
library(dplyr)
library(yaml)
#library(DT)
library("devtools")


# much of the code below is adapted from or taken from
# https://deanattali.com/2015/06/14/mimicking-google-form-shiny/
# 

fieldsMandatory <- c("version", "postDate", "sharerName", "sharerEmail","label","description")

labelMandatory <- function(label) {
  tagList(
    label,
    span("*", class = "mandatory_star")
  )
}

# create the ui
ui <- fluidPage(
  
  shinyjs::useShinyjs(),
  # Application title
  titlePanel(HTML("<span style=\"color:white; background-color: #686868\">&nbsp;Open</span><span style=\"color:#0af70a; background-color: #686868\">Drawer  </span> data declaration form")),
  mainPanel( 
    
    div(id = "form",
    h4("ID"),
    # each of the sections of code below create a text input box with a title
    #textInput("id", "ID", "### Generated by R package, not sure how to implement"), #   HTML("#Generated by R package, not sure how to implement"),
    verbatimTextOutput("id3"),
    #tableOutput("display_id"),
    
    
    
    textInput("version", "Version"),
    #verbatimTextOutput("postDate"),
    
    textInput("postDate", HTML("Date uploaded <br><i>(in ISO format: '2019-07-31')</i>")),
    #verbatimTextOutput("postDate"), # this line simply displays what has been inputted into the text field
    
    textInput("sharerName", "Name"),
    #verbatimTextOutput("sharerName"),
    
    textInput("sharerEmail", "E-mail address"),
    #verbatimTextOutput("sharerEmail"),
    
    textInput("label", HTML("Label <br><i>(short name for project)</i>")),
    #verbatimTextOutput("label"),
    
    textInput("description", HTML("<b>Description<b></br> (eg - <i>In year ...., I collected ....,
    [but I didn't end up publishing it because my hamster ate the questionnaires]. The keywords are [open science
    and attitudes].</i>"))
    #, verbatimTextOutput("description")
    
    #h3("Basic Table to Updtate as fields are completed"),
    # tableOutput("table2")
    #,
    #h3("Table displaying content saved to YAML file"),
    # DT::dataTableOutput("table1")
    ,
    br(),
    
    actionButton("submit", "Submit", class = "btn-primary")
    , br(),br()
    , HTML("(cannot submit until all fields are filled)")
    
    , shinyjs::hidden(
      span(id = "submit_msg", "Submitting..."),
      div(id = "error",
          div(br(), tags$b("Error: "), span(id = "error_msg"))
      )
    )
  )
  ),
  
  #DT::dataTableOutput("table1"),
  
  #div(id = "form", ...),
  shinyjs::hidden(
    div(
      id = "thankyou_msg",
      h3("Thanks, your response was submitted successfully!"),
      HTML("The information you submitted is displayed below"),
      DT::dataTableOutput("table1b"),
      actionLink("submit_another", "Submit another response")
    )
  )  
  
  
  
)

# Define server logic required to draw a histogram
server <- function(input, output, session) {
  
  # The lines below create objects from the input
  output$sharerEmail <-  renderText({ input$sharerEmail })
  output$postDate  <- renderText({ input$postDate })
  output$sharerName  <- renderText({ input$sharerName })
  output$label  <- renderText({ input$label })
  output$description  <- renderText({ input$description })
  #output$full_id <-    renderText({rock::numericToBase30(as.numeric(Sys.time())*10000)})

  
  #output$table <- cbind(input$sharerEmail, input$postDate)
  
  # get data object
  get_list<-reactive({

   # if(!exists(input$sharerEmail)) return() # if no upload

  #  check<-function(x){is.null(x) || x==""}
    #if(check(input$sharerEmail)) return()

    obj<-list(#data=get(input$dataset),
      #id=input$id,
      id=rock::numericToBase30(as.numeric(Sys.time())*10000),
      version=input$version,
      postDate=input$postDate,
      sharerName=input$sharerName,
      sharerEmail=input$sharerEmail,
      label=input$label,
      description=input$description
    )

    #require all to be set to proceed
    #if(any(sapply(obj,check))) return()
    
    #make sure choices had a chance to update
    # check<-function(obj){
    #   !all(c(obj$dv,obj$iv,obj$mediator) %in% colnames(obj$data))
    # }
    # 
    # if(check(obj)) return()


    obj

  })
  
  output$id2 <- reactive({big_list <- get_list()
  big_list$id})
  
  fieldsAll <- c("id", "version", "postDate", "sharerName", "sharerEmail","label","description")
  responsesDir <- file.path("responses")
  epochTime <- function() {
    as.integer(Sys.time())
  }
  
  output$id3 <- reactive({print("automatically generated on submit")})
  
  get_list_as_df<-reactive({
    
    # if(!exists(input$sharerEmail)) return() # if no upload
    
    #  check<-function(x){is.null(x) || x==""}
    #if(check(input$sharerEmail)) return()
    
    # obj<-list(#data=get(input$dataset),
    #   id=input$id,
    #   version=input$version,
    #   postDate=input$postDate,
    #   sharerName=input$sharerName,
    #   sharerEmail=input$sharerEmail,
    #   label=input$label,
    #   description=input$description
    # )
    
    #require all to be set to proceed
    #if(any(sapply(obj,check))) return()
    
    #make sure choices had a chance to update
    # check<-function(obj){
    #   !all(c(obj$dv,obj$iv,obj$mediator) %in% colnames(obj$data))
    # }
    # 
    # if(check(obj)) return()
    
    
    data <- sapply(fieldsAll, function(x) input[[x]])
    data <- c(data, timestamp = epochTime())
    data <- t(data)
    data
    
    #obj
    
  })
  
  
  observeEvent(input$file1,{
    inFile<<-upload_data()
  })
  
  
  
  #output$table3 <- output$table1$sharerEmail
  
  output$table2 <- renderTable({ big_list <- get_list()
  a <- rbind(
    #c("id","version","date","sharerName", "sharerEmail","label", "description"),
    c(big_list$id,
      big_list$version,
      big_list$postDate,
      big_list$sharerName,
      big_list$sharerEmail,
      big_list$label,
      big_list$description))
  colnames(a)<- c("ID","Version","Date","Name", "Email","Label", "Description")
  a
  })
  
  
  output$display_id <- renderTable({ big_list <- get_list()
  a <- rbind(
    c(big_list$id ))
  colnames(a)<- c("ID")
  a
  })
  

  
  id_for_file_name <- reactive({big_list <- get_list()
  big_list$id})
  
    
  
  
  saveData <- function(data){
    fileName <- sprintf("%s.yml",
                        id_for_file_name()
                        #,
                        #digest::digest(data)
                        )
  # write_yaml(stats::setNames(list(list(id = "testId", version=1, postDate="now")), "data_declaration"), stdout())
    write_yaml(stats::setNames(list(data), "data_declaration"), file = file.path(responsesDir, fileName))
  }
  
  
  # action to take when submit button is pressed
  observeEvent(input$submit, {
    saveData(get_list())
    id_open_file <- id_for_file_name()
  })
  
  observe({
    # check if all mandatory fields have a value
    mandatoryFilled <-
      vapply(fieldsMandatory,
             function(x) {
               !is.null(input[[x]]) && input[[x]] != ""
             },
             logical(1))
    mandatoryFilled <- all(mandatoryFilled)
    
    # enable/disable the submit button
    shinyjs::toggleState(id = "submit", condition = mandatoryFilled)
  })
  
  observeEvent(input$submit, {
    shinyjs::disable("submit")
    shinyjs::show("submit_msg")
    shinyjs::hide("error")
    
    tryCatch({
      #saveData(formData())
      shinyjs::reset("form")
      shinyjs::hide("form")
      shinyjs::show("thankyou_msg")
    },
    error = function(err) {
      shinyjs::html("error_msg", err$message)
      shinyjs::show(id = "error", anim = TRUE, animType = "fade")
    },
    finally = {
      shinyjs::enable("submit")
      shinyjs::hide("submit_msg")
    })
  })
  
  output$table1 <- DT::renderDataTable({ big_list <- get_list()
  a <- rbind(
    #c("id","version","date","sharerName", "sharerEmail","label", "description"),
    c(big_list$id,
      #output$full_id,
      big_list$version,
      big_list$postDate,
      big_list$sharerName,
      big_list$sharerEmail,
      big_list$label,
      big_list$description))
  colnames(a)<- c("ID","Version","Date","Name", "Email","Label", "Description")
  a
  },options = list(lengthChange = FALSE,paging = FALSE))
  
  get_list_2 <- reactive({
    
    fileName2 <- sprintf("%s.yml",
            #id_open_file
            id_for_file_name()
            #,
            #digest::digest(data)
    )
    
    id_for_file_name3 <- reactive({
      df_name <- file.info(list.files("responses", full.names = T))
      rownames(df_name)[which.max(df_name$mtime)]
      #big_list <- get_list()
      #big_list$id
    })
      
    fileName3 <-  sprintf(#"%s.yml",
                          #id_open_file
                          id_for_file_name3()
                          #,
                          #digest::digest(data)
    )
    
    # inputteddata <- read_yaml(file = "responses/rzqxmwgd0.yml")
    # inputteddata <- read_yaml(file = file.path(responsesDir, fileName2))
    inputteddata <- read_yaml(file = id_for_file_name3())
    
  obj<-list(#data=get(input$dataset),
    #id=input$id,
    id=inputteddata$data_declaration$id,
    version=inputteddata$data_declaration$version,
    postDate=inputteddata$data_declaration$postDate,
    sharerName=inputteddata$data_declaration$sharerName,
    sharerEmail=inputteddata$data_declaration$sharerEmail,
    label=inputteddata$data_declaration$label,
    description=inputteddata$data_declaration$description
  )
  
  obj
  
  })
  
  output$table1b <- DT::renderDataTable({ big_list1 <- get_list_2()
  a <- rbind(
    #c("id","version","date","sharerName", "sharerEmail","label", "description"),
    c(big_list1$id,
      #output$full_id,
      big_list1$version,
      big_list1$postDate,
      big_list1$sharerName,
      big_list1$sharerEmail,
      big_list1$label,
      big_list1$description))
  colnames(a)<- c("ID","Version","Date","Name", "Email","Label", "Description")
  a
  },options = list(lengthChange = FALSE,paging = FALSE))
  
}

# Run the application 
shinyApp(ui = ui, server = server)

