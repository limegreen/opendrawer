library(shiny)
library(foreign)
library(purrr)
library(dplyr)
#library(DT)
library("devtools")



# create the ui
ui <- fluidPage(
  
  # Application title
  titlePanel("Free the Data (or SPRING or NECTAR)"),
  mainPanel( 
    
    # each of the sections of code below create a text input box with a title
    textInput("id", "ID", "### Generated by R package, not sure how to implement"), #   HTML("#Generated by R package, not sure how to implement"),
    
    textInput("version", "Version", "version"),
    #verbatimTextOutput("postdate"),
    
    textInput("postdate", "Date uploaded", "Date in ISO format (2019-07-31)"),
    #verbatimTextOutput("postdate"), # this line simply displays what has been inputted into the text field
    
    textInput("name", "Name", "Please type your name here"),
    #verbatimTextOutput("name"),
    
    textInput("email", "E-mail address", "type your email address here"),
    #verbatimTextOutput("email"),
    
    textInput("label", "Data set label", "a short label for your data"),
    #verbatimTextOutput("label"),
    
    textInput("description", "Description", "a description of the data"),
    #verbatimTextOutput("description")
    
    h3("Basic Table to Updtate as fields are completed"),
     tableOutput("table2")
    ,
    h3("Table Displaying Object that (hopefully) will be saved to YAML"),
     DT::dataTableOutput("table1")
    
  )
)

# Define server logic required to draw a histogram
server <- function(input, output, session) {
  
  # The lines below create objects from the input
  output$email <-  renderText({ input$email })
  output$postdate  <- renderText({ input$postdate })
  output$name  <- renderText({ input$name })
  output$label  <- renderText({ input$label })
  output$description  <- renderText({ input$description })
  
  
  #output$table <- cbind(input$email, input$postdate)
  
  # get data object
  get_list<-reactive({

   # if(!exists(input$email)) return() # if no upload

  #  check<-function(x){is.null(x) || x==""}
    #if(check(input$email)) return()

    obj<-list(#data=get(input$dataset),
      id=input$id,
      version=input$version,
      postdate=input$postdate,
      name=input$name,
      email=input$email,
      label=input$label,
      description=input$description
    )

    #require all to be set to proceed
    #if(any(sapply(obj,check))) return()
    
    #make sure choices had a chance to update
    # check<-function(obj){
    #   !all(c(obj$dv,obj$iv,obj$mediator) %in% colnames(obj$data))
    # }
    # 
    # if(check(obj)) return()


    obj

  })
  observeEvent(input$file1,{
    inFile<<-upload_data()
  })
  
  output$table1 <- DT::renderDataTable({ big_list <- get_list()
                              a <- rbind(
                                #c("id","version","date","name", "email","label", "description"),
                                c(big_list$id,
                                  big_list$version,
                                  big_list$postdate,
                                  big_list$name,
                                  big_list$email,
                                  big_list$label,
                                  big_list$description))
                              colnames(a)<- c("ID","Version","Date","Name", "Email","Label", "Description")
                              a
                              },options = list(lengthChange = FALSE,paging = FALSE))
  
  #output$table3 <- output$table1$email
  
  output$table2 <- renderTable({ big_list <- get_list()
  a <- rbind(
    #c("id","version","date","name", "email","label", "description"),
    c(big_list$id,
      big_list$version,
      big_list$postdate,
      big_list$name,
      big_list$email,
      big_list$label,
      big_list$description))
  colnames(a)<- c("ID","Version","Date","Name", "Email","Label", "Description")
  a
  })
  
  
}

# Run the application 
shinyApp(ui = ui, server = server)

